<!DOCTYPE html>
<html>
  <head>
    <title>Maze Generation Prototype</title>
    <script type="text/javascript" src="http:threejs.org/build/three.min.js"></script>
    <script type="text/javascript" src="http:code.jquery.com/jquery-2.1.4.min.js"></script>
    <style>
      body{margin: 0;overflow: hidden;}
    </style>
  </head>
  <body>
    <div id="WebGL-output"></div>
    <div id="Stats-output"></div>
      <script type="text/javascript">
      $(function(){ 	
		function mazegen(x,y) {
			var n=x*y-1;
			if (n<1 || n>Math.pow(200,2)) {alert("illegal maze dimensions");return;}
			var wx=[];
			for (var j=0;j<y+1;j++){
				wx[j]=[];
				for (var k=0;k<x;k++) {wx[j][k]=false};
			};
			var wy=[];
			for (var j=0;j<x+1;j++){
				wy[j]=[];
				for (var k=0;k<y;k++) {wy[j][k]=false};
			};
			var unvisited = [];
			for (var j=0;j<x;j++){
				unvisited[j]=[];
				for (var k=0;k<y;k++) {
					unvisited[j][k]=1;
				};
			};
			start = [Math.floor(Math.random()*x),Math.floor(Math.random()*y)];
			var here = start;
			unvisited[here[0]][here[1]]=0;
			var path = [here];
			var dead = 0;
			deadends=[here];
			while(n>0) {
				var potential = [];
				var neighbors = [];
				if (here[0]+1<x) {potential.push([here[0]+1,here[1]])};
				if (here[1]+1<y) {potential.push([here[0],here[1]+1])};
				if (here[0]-1>=0) {potential.push([here[0]-1,here[1]])};
				if (here[1]-1>=0) {potential.push([here[0],here[1]-1])};
				for (j=0;j<potential.length;j++) {
					if (unvisited[potential[j][0]][potential[j][1]]==1) {neighbors.push(potential[j])};
				};
				if (neighbors.length){
					n--;
					next = neighbors[Math.floor(Math.random()*neighbors.length)];
					unvisited[next[0]][next[1]]=0;
					if (next[0]==here[0]) {
						wx[Math.ceil((next[1]+here[1])/2)][next[0]]=true;
					}
					else {
						wy[Math.ceil((next[0]+here[0])/2)][next[1]]=true;
					};
					path.push(next);
					here = next;
					dead = 0;
				}
				else {
					here=path.pop();
					if (dead == 0) {dead = 1; deadends.push(here)};
				};
			};
			deadends.push(here);
			if (deadends.length==1) {deadends.push(start)};
			
						
			var pairs = [];
			for (var i=0;i<deadends.length-1;i++) {
				var dx = deadends[i];
				for (var j=i;j<deadends.length-1;j++) {
					var dy = deadends[j+1];
					pairs.push([dx,dy]);
				};
			};			
			var iterations = Math.min(Math.floor(0.5*deadends.length*(deadends.length-1)),Math.floor(5000/(x*y/Math.pow(33,2))));
			var maxpath = [];
			while (iterations > 0) {
				currentpair = pairs.splice(Math.floor(Math.random()*pairs.length),1);
				var start = currentpair[0][0];
				var end = currentpair[0][1];
				path = [];
				path.push(start);
				here = start;
				unvisited = [];
				for (var j=0;j<x;j++){
					unvisited[j]=[];
					for (var k=0;k<y;k++) {
						unvisited[j][k]=1;
					};
				};
				unvisited[here[0]][here[1]]=0;
				var popp = false;
				while (!(here[0] == end[0] && here[1] == end[1])) {
					var neighbors = [];
					var potential = [];
					if (here[0]+1<x) {potential.push([here[0]+1,here[1]])};
					if (here[1]+1<y) {potential.push([here[0],here[1]+1])};
					if (here[0]-1>=0) {potential.push([here[0]-1,here[1]])};
					if (here[1]-1>=0) {potential.push([here[0],here[1]-1])};
					for (j=0;j<potential.length;j++) {
						if (unvisited[potential[j][0]][potential[j][1]]==1 && ((potential[j][0]==here[0]&&(wx[Math.ceil((potential[j][1]+here[1])/2)][potential[j][0]]==true)) || (potential[j][1]==here[1] && wy[Math.ceil((potential[j][0]+here[0])/2)][potential[j][1]]==true))) {
							neighbors = potential[j];
						};
					};
					if(neighbors.length==2) {
						if (popp == true) {
							popp = false;
							path.push(here);
						}
						next = neighbors;
						path.push(next);
						here = next;
						unvisited[next[0]][next[1]]=0;
					}
					else {here = path.pop(); var popp = true};
				};
				if (maxpath.length<path.length) {maxpath = path; fstart=start;  fend=end;};
				iterations--;
			};
			pgeom.position.set(-3.75*x+7.5*(fstart[0]+0.5),pgeom.position.y,-3.75*x+7.5*(fstart[1]+0.5+(x-y)/2));
			skybox.position.set(pgeom.position.x,pgeom.position.y,pgeom.position.z);
			egeom.position.set(-3.75*x+7.5*(fend[0]+0.5),egeom.position.y,-3.75*x+7.5*(fend[1]+0.5+(x-y)/2));

			if (maxpath.length >= 4) {
				maxpath.pop();
				maxpath.shift();
				var mplpick = Math.random()*maxpath.length;
				beforecoords = maxpath[Math.ceil(mplpick/4+maxpath.length/2)-2];
				doorcoords = maxpath[Math.ceil(mplpick/4+maxpath.length/2)-1];
				if (doorcoords[0] != beforecoords[0]){orient = "horiz"}
				else {orient = "vert"};
				keypath = [];
				var popp = false;
				while (keypath.length <= 0) {
					start = fstart;
					selection = deadends.splice(Math.floor(Math.random()*deadends.length),1)
					end = [selection[0][0],selection[0][1]];
					path = [];
					path.push(start);
					here = start;
					unvisited = [];
					for (var j=0;j<x;j++){
						unvisited[j]=[];
						for (var k=0;k<y;k++) {
							unvisited[j][k]=1;
						};
					};
					unvisited[here[0]][here[1]]=0;
					unvisited[doorcoords[0]][doorcoords[1]]=0;
					while (!(here[0] == end[0] && here[1] == end[1]) && (path.length > 0)) {
						var neighbors = [];
						var potential = [];
						if (here[0]+1<x) {potential.push([here[0]+1,here[1]])};
						if (here[1]+1<y) {potential.push([here[0],here[1]+1])};
						if (here[0]-1>=0) {potential.push([here[0]-1,here[1]])};
						if (here[1]-1>=0) {potential.push([here[0],here[1]-1])};
						for (j=0;j<potential.length;j++) {
							if (unvisited[potential[j][0]][potential[j][1]]==1 && ((potential[j][0]==here[0]&&(wx[Math.ceil((potential[j][1]+here[1])/2)][potential[j][0]]==true)) || (potential[j][1]==here[1] && wy[Math.ceil((potential[j][0]+here[0])/2)][potential[j][1]]==true))) {
								neighbors = potential[j];
							};
						};
						if(neighbors.length==2) {
							if (popp == true) {
								popp = false;
								path.push(here);
							}
							next = neighbors;
							path.push(next);
							here = next;
							unvisited[next[0]][next[1]]=0;
						}
						else {here = path.pop(); popp = true};
					};
					if (keypath.length<path.length) {
					keypath = path;
					var kend=end;
					};
				};
				if (kend[0] == fstart[0] && kend[1] == fstart[1]) {kend = maxpath[Math.ceil(Math.random()*maxpath.length/2)-1]};
				
				var keyring = new THREE.Shape();
				var keyhole = new THREE.Path();
				var stick = new THREE.Shape();
				keyring.moveTo(0,0);
				keyring.absellipse(0,0,0.5,0.3125,0,Math.PI*1.95,false);
				keyhole.moveTo(0,0);
				keyhole.absellipse(0,0,0.375,0.1875,0,Math.PI*1.95,true);
				keyring.holes.push(keyhole)
				stick.moveTo(0.0625,0.25);
				stick.lineTo(0.0625,0.875);
				stick.lineTo(0.1875,0.875);
				stick.lineTo(0.1875,1)
				stick.lineTo(0.0625,1);  //keyspace
				stick.lineTo(0.0625,1.125); //keyspace
				stick.lineTo(0.25,1.125);
				stick.lineTo(0.25,1.25)
				stick.lineTo(-0.0625,1.25);
				stick.lineTo(-0.0625,0.25);
				
				var extrudeSettings = {amount: 0.125, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.05, bevelThickness: 0.05};
					
				kgeom = new THREE.ExtrudeGeometry(keyring,extrudeSettings);
				var geom = new THREE.ExtrudeGeometry(stick,extrudeSettings);
				kgeom.merge(geom);
				doorcolor = new THREE.Color;
				doorcolor.setHSL(Math.random(),1,0.5);
				demissive = doorcolor;
				demissive.offsetHSL(0,0,-0.2);
				var material = new THREE.MeshPhongMaterial({color:doorcolor,emissive:demissive,shininess:100});
				key = new THREE.Mesh(kgeom,material);
				key.position.set(-3.75*x+7.5*(kend[0]+0.5),1.75,-3.75*x+7.5*(kend[1]+0.5+(x-y)/2));
				key.rotation.x += Math.PI;
				key.rotation.z -= Math.PI/8;
				key.name = "key1";
				scene.add(key);
				
				if (orient == "horiz") {doorgeom = new THREE.BoxGeometry(2,2,5.5,2,2,5);}
				else {doorgeom = new THREE.BoxGeometry(5.5,2,2,5,2,2)};
				for (var i=1;i<doorgeom.faces.length+1;i+=2){
				var hcol = Math.random()*0.1+doorcolor.getHSL().h-0.05;
				var lcol = Math.random()*0.125+0.5-0.0625;
				doorgeom.faces[i].color.setHSL(hcol,1,lcol);
				doorgeom.faces[i-1].color.setHSL(hcol,1,lcol)};
				
				var emat = new THREE.MeshBasicMaterial({color:0xffffff,vertexColors:THREE.FaceColors});
				doormesh = new THREE.Mesh(doorgeom,emat);
				if (orient == "horiz") {
					if (beforecoords[0]>doorcoords[0]) {var buffer = 3.75}
					else {var buffer = -3.75};
					doormesh.position.set(-3.75*x+7.5*(doorcoords[0]+0.5)+buffer,1.5,-3.75*x+7.5*(doorcoords[1]+0.5+(x-y)/2));
				}
				else {
					if (beforecoords[1]>doorcoords[1]) {var buffer = 3.75}
					else {var buffer = -3.75};
					doormesh.position.set(-3.75*x+7.5*(doorcoords[0]+0.5),1.5,-3.75*x+7.5*(doorcoords[1]+0.5+(x-y)/2)+buffer);
				}
				doormesh.name = "door1";
				walls.push(doormesh);
				scene.add(doormesh);
			}
			
			for (var j=0;j<x+1;j++) {
				for (var k=0;k<y+1;k++) {
						xpos = -3.75*x+7.5*(j);
						ypos = -3.75*y+7.5*(k);
						var geom = new THREE.Mesh(new THREE.BoxGeometry(2,2,2),rcolor(xpos,ypos,1));
						geom.position.set(xpos,1.5,ypos);
						walls.push(geom);
						scene.add(geom);
				}
			}
			for (var j=0;j<x+1;j++) {
				for (var k=0;k<y;k++) {
					if (!(wy[j][k])) {
						xpos = -3.75*x+7.5*(j);
						ypos = -3.75*y+7.5*(k+0.5);
						var hgeom = new THREE.Mesh(new THREE.BoxGeometry(2,2,5.5),rcolor(xpos,ypos));
//						var hgeom = new THREE.Mesh(new THREE.BoxGeometry(2,2,9.5),rcolor(xpos,ypos));
						hgeom.position.set(xpos,1.5,ypos);
						walls.push(hgeom);
						scene.add(hgeom);
					};
				};
			};
			for (var j=0;j<y+1;j++) {
				for (var k=0;k<x;k++) {
					if (!(wx[j][k])) {
						xpos = -3.75*x+7.5*(j+(x-y)/2);
						ypos = -3.75*y+7.5*(k+0.5-(x-y)/2);
						var vgeom = new THREE.Mesh(new THREE.BoxGeometry(5.5,2,2),rcolor(xpos,ypos));
//						var vgeom = new THREE.Mesh(new THREE.BoxGeometry(9.5,2,2),rcolor(xpos,ypos));
						vgeom.position.set(ypos,1.5,xpos);
						walls.push(vgeom);
						scene.add(vgeom);
					};
				};
			};		
			return;
		};		
						
		document.addEventListener('keydown', function(event) {
			if((event.keyCode == 37 || event.keyCode == 65) && moving==false && rotating==false) {
				rotating = true;
				fdir.applyAxisAngle(new THREE.Vector3(0,1,0),Math.PI/2);
				bdir.applyAxisAngle(new THREE.Vector3(0,1,0),Math.PI/2);
				fray.set(pgeom.position,fdir);
				bray.set(pgeom.position,bdir);
				step = Math.PI/Math.floor(fps/6)/2;
				timer = Math.floor(fps/6);
			}
			else if((event.keyCode == 39 || event.keyCode == 68) && moving==false && rotating==false) {
				rotating = true;
				fdir.applyAxisAngle(new THREE.Vector3(0,1,0),-Math.PI/2);
				bdir.applyAxisAngle(new THREE.Vector3(0,1,0),-Math.PI/2);
				fray.set(pgeom.position,fdir);
				bray.set(pgeom.position,bdir);
				step = -Math.PI/Math.floor(fps/6)/2;
				timer = Math.floor(fps/6);
			}
			else if((event.keyCode == 38 || event.keyCode == 87) && moving==false && rotating==false) {
				scene.updateMatrixWorld();
				ctest = fray.intersectObjects(walls);
				for (i=0;i<ctest.length;i++) {
					for (j=0;j<inventory.length;j++) {
						if (doormesh.name == ctest[i].object.name && key.name == inventory[j]) {
							scene.remove(scene.getObjectByName(doormesh.name));
							pgeom.remove(key);
							walls.shift();
							inventory.pop();
						}
					}
				};
				moving = true;
				if (ctest.length>0) {open=0}
				else {open=1};
				step = -7.5/Math.floor(fps/6)*open;
				timer = Math.floor(fps/6)*open;
				if (startTime == 0) {startTime = Date.now()};
			}
			else if((event.keyCode == 40 || event.keyCode == 83) && moving==false && rotating==false){
				scene.updateMatrixWorld();
				ctest = bray.intersectObjects(walls);
				for (i=0;i<ctest.length;i++) {
					for (j=0;j<inventory.length;j++) {
						if (doormesh.name == ctest[i].object.name && key.name == inventory[j]) {
							scene.remove(scene.getObjectByName(doormesh.name));
							pgeom.remove(key);
							walls.shift();
							inventory.pop();
						}
					}
				};
				moving = true;
				if (ctest.length>0) {open=0}
				else {open=1};
				step = 7.5/Math.floor(fps/6)*open;
				timer = Math.floor(fps/6)*open;
				if (startTime == 0) {startTime = Date.now()};
			}
		});		
		
		window.addEventListener( 'resize', onWindowResize, false );

		function onWindowResize(){
			
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			camera2.aspect = window.innerWidth / window.innerHeight;
			camera2.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}		
		
		String.prototype.toHHMMSS = function () {
			var sec_num = parseInt(this, 10); // don't forget the second param
			var hours   = Math.floor(sec_num / 3600000);
			var minutes = Math.floor((sec_num - (hours * 3600000)) / 60000);
			var seconds = (sec_num - (hours * 3600000) - (minutes * 60000))/1000;

			if (hours   < 10) {hours   = "0"+hours;}
			if (minutes < 10) {minutes = "0"+minutes;}
			if (seconds < 10) {seconds = "0"+seconds;}
			var time    = hours+':'+minutes+':'+seconds;
			return time;
		}		
		
		function init() {
			sign = new Array();
			rainbow = new THREE.Color();
			rainbow.setHSL(Math.random(),0.75,0.1);
			wallcolor = new THREE.Color();
			wallcolor.setHSL(Math.random(),1,0.75);
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight,1,100);
			camera2 = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight,1,1000);
			renderer = new THREE.WebGLRenderer({antialias:false});
//	        renderer.setClearColor(0x9CB4FF, 1.0);
//	        renderer.setClearColor(0x011627, 1.0);
			renderer.setClearColor(0x000000, 1.0);
			renderer.setSize(window.innerWidth, window.innerHeight);
			inventory = [];
			win = false;
			startTime = 0;
			time = Date.now();
			ptime = Date.now();
			fps = 30;
			frames = 0;
						
			text2 = document.createElement('div');
			text2.style.position = 'absolute';
			text2.style.zIndex = 1;
			text2.style.width = 100;
			text2.style.height = 100;
			text2.style.color = "white";
			text2.style.fontSize = "400%";
			text2.style.fontWeight = "bold";
			text2.style.fontFamily = "Helvetica";
			text2.innerHTML = "";
			text2.style.top = 0 + 'px';
			text2.style.left = 13 + 'px';
			document.body.appendChild(text2);

			
			rotating = false;
			moving = false;
			step = 0;
			timer = 0;
			
			light = new THREE.DirectionalLight(0xFFFFFF, 1);
			light.position.set(-50,30,-30);
			light.lookAt({x:0,y:0,z:0});
			light2 = new THREE.DirectionalLight(0xFFFFFF, .5);
			light2.position.set(50,30,30);
			light2.lookAt({x:0,y:0,z:0});
			
			scene.add(light);
			scene.add(light2);
			
			walls = new Array();
			
			pmat = new THREE.MeshLambertMaterial({opacity:0,color:(0xFF0000),transparent:true});
			pgeom = new THREE.Mesh(new THREE.BoxGeometry(2.5,2,2.5),pmat);
					
			ogeom = new THREE.IcosahedronGeometry(0.5,2);
			minigeom = new THREE.IcosahedronGeometry(0.2,1)
			for (var i=0;i<ogeom.faces.length;i++) {
				ogeom.faces[i].color.setHSL(Math.random(),1,0.5);
			};
			for (var i=0;i<minigeom.faces.length;i++) {
				minigeom.faces[i].color.setHSL(Math.random(),1,0.5);
			};

			var emat = new THREE.MeshBasicMaterial({color:0xffffff,vertexColors:THREE.FaceColors});
			egeom = new THREE.Mesh(ogeom,emat);
			mgeom = new THREE.Mesh(minigeom,emat);
			egeom.add(mgeom);
			mgeom.position.set(0.8,0,0);
						
			pgeom.position.set(-3.75*x+3.75,1.5,-3.75*y+3.75);
			egeom.position.set(3.75*x-3.75,1.5,3.75*y-3.75);
			
			
//			var skygeom = new THREE.BoxGeometry(100,100,100)
			var skygeom = new THREE.SphereGeometry(90,15,15);
//			var sktop = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars_top.jpg'), side:THREE.BackSide});
//			var skbot = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars_top.jpg'), side:THREE.BackSide});
//			var skleft = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars_left.jpg'), side:THREE.BackSide});
//			var skright = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars_right.jpg'), side:THREE.BackSide});
//			var skfront = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars_front.jpg'), side:THREE.BackSide});
//			var skback = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars_back.jpg'), side:THREE.BackSide});
			var skymat = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('stars/stars.png'), side:THREE.BackSide});
//			var skymat = new THREE.MeshFaceMaterial([skfront,skback,sktop,skbot,skleft,skright]);
			skybox = new THREE.Mesh(skygeom,skymat)
			skybox.visible = false;
			scene.add(skybox);
			pgeom.add(camera);
			camera.position.set(4.6,0,0);
			camera.rotation.y += Math.PI/2;
			
			cstep = (x+y)*(9/300)/2;
			cangle = -Math.PI/600;
			ctimer = 300;
			camera2.position.set(0,10,0);
			camera2.lookAt(new THREE.Vector3(0,0,0));
			
			scene.add(camera2);
			scene.add(pgeom,egeom);
			

			fdir = new THREE.Vector3(-1,0,0);
			bdir = new THREE.Vector3(1,0,0);
						
			fray = new THREE.Raycaster(pgeom.position,fdir,0,7.5);		
			bray = new THREE.Raycaster(pgeom.position,bdir,0,7.5);	
						
//	        fgeom = new THREE.Mesh(new THREE.BoxGeometry(2.5+7.5*x,1,2.5+7.5*y), new THREE.MeshLambertMaterial({opacity:1,color:new THREE.Color().setHSL(120/360,1,0.35)}));
//			fgeom = new THREE.Mesh(new THREE.BoxGeometry(2.5+7.5*x,1,2.5+7.5*y), new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(0,0,0)}));
//			fgeom = new THREE.Mesh(new THREE.BoxGeometry(2.5+7.5*x,1,2.5+7.5*y), new THREE.MeshLambertMaterial({color:0x011627}));
//	        fgeom = new THREE.Mesh(new THREE.BoxGeometry(2+7.5*x,1,2+7.5*y), new THREE.MeshLambertMaterial({opacity:0.85,color:0x20b6df}));
//			walls.push(fgeom);
//			scene.add(fgeom);
		};
		
		function rcolor(xpos,ypos,solid) {
//			ired=000/255;
//			igreen=Math.random()*75/255+75/255;
//			iblue=000/255;
//			fred=Math.random()*50/255+20/255;
//			fgreen=50/255;
//			fblue=000/255;
			ired=255/255;
			igreen=255/255;
			iblue=000/255;
			fred=255/255;
			fgreen=000/255;
			fblue=255/255;
			maxdist = Math.floor(Math.sqrt(Math.pow(2.5+7.5*x,2)+Math.pow(1,2.5+7.5*y,2)));
			dist = Math.floor(Math.sqrt(Math.pow(xpos+3*x,2)+Math.pow(ypos+3*y,2)));
			distratio = dist/maxdist+(Math.random()-0.5);
//			distratio = dist/maxdist;
			rdelt=fred-ired;
			gdelt=fgreen-igreen;
			bdelt=fblue-iblue;
			fred=distratio*rdelt+ired;
			fgreen=distratio*gdelt+igreen;
			fblue=distratio*bdelt+iblue;
			fcolor = new THREE.Color(fred,fgreen,fblue);
			if (fcolor.getHSL().l<0.5) {fcolor=new THREE.Color(Math.random(),Math.random(),Math.random());fcolor.setHSL(fcolor.getHSL().h,1,0.5)};
			if (solid==1) {
//				reco = new THREE.Color(fred, fgreen, fblue);
//				reco.offsetHSL(0.33,0,0.5);
//				renderer.setClearColor(reco,1);
//				fcolor.offsetHSL(0.66,0,0.3);
				tr = false
			}
			else if (solid==0) {tr=true}
			else if (Math.random()>=0.5){tr=true}
			else {tr=false};
//			fcolor = new THREE.Color(Math.random(),Math.random(),Math.random());
			fcolor = new THREE.Color(wallcolor);
//			fcolor = new THREE.Color(1,1,1);
//			fcolor.setHSL(fcolor.getHSL().h,fcolor.getHSL().s,Math.random()*.25+.75);
//			fcolor.setHSL(fcolor.getHSL().h,fcolor.getHSL().s,0.5);
			var mat = new THREE.MeshLambertMaterial({opacity:0.75,color:fcolor,transparent:tr});
//			var mat = new THREE.MeshLambertMaterial({opacity:1,color:fcolor,transparent:false});
			return mat;
		}
		
		function renderScene() {						
//			for (i=0;i<walls.length;i++){walls[i].material.color.offsetHSL(0.003,0,0)};
//			pgeom.material.color.offsetHSL(0.03,0,0);
//			fgeom.material.color=pgeom.material.color.clone();
//			fgeom.material.color.offsetHSL(0.005,0,0);

//			for (i=0;i<walls.length;i++){walls[i].material.color.offsetHSL(0.002,0,0)};
			
//			rainbow.offsetHSL(0.002,0,0);
			renderer.setClearColor(rainbow.getHex(),1);
			
//			for (i=0;i<walls.length;i++){
//				state = walls[i].material.color.getHSL();
//				if (state.l<=0.15) {sign[i]=0.6; walls[i].material.color.offsetHSL(1/8,0,0);}
//				else if (state.l >=0.5) {sign[i]=-1.4}
//				walls[i].material.color.offsetHSL(0,0,0.0033*sign[i])
//			};
			
//			for (i=0;i<walls.length;i++){
//				state = walls[i].material.color.getHSL();
//				if (state.l<=0.15) {sign[i]=0.6}
//					else if (state.l >=0.5) {sign[i]=-1.4}
//				if (! walls[i].name) {
//				walls[i].material.color.offsetHSL(0,0,0.0033*sign[i])};
//			};
			
//			egeom.rotation.y+=0.02;
//			egeom.rotation.z+=0.06;
//			mgeom.rotation.y+=0.05;
//			mgeom.rotation.z+=0.025;
			egeom.rotation.y+=0.02/1.5;
			egeom.rotation.z+=0.06/1.5;
			mgeom.rotation.y+=0.05/1.5;
			mgeom.rotation.z+=0.025/1.5;
			skybox.rotation.y+=0.0005;
			skybox.rotation.z+=0.001;
			
			for (var i=0;i<egeom.geometry.faces.length;i++) {
				egeom.geometry.faces[i].color.offsetHSL(0.0033,0,0);
			};
			egeom.geometry.colorsNeedUpdate = true;
			
			if (moving==true && timer>0) {pgeom.translateX(step); skybox.position.set(pgeom.position.x,pgeom.position.y,pgeom.position.z); timer-=1}
			if (rotating==true && timer>0) {pgeom.rotation.y+=step; ; timer-=1}
			if ((moving==false && rotating==false) || timer<1) {moving=false; rotating=false; timer=0};
			requestAnimationFrame(renderScene);
			if (win==true && ctimer>0) {
				camera2.translateZ(cstep);
				camera2.rotation.z+=cangle;
				ctimer--;
			};
			if (win==true) {renderer.render(scene,camera2)}
			else {renderer.render(scene,camera)};
			if (Math.floor(pgeom.position.x.toFixed(2))==Math.floor(egeom.position.x.toFixed(2)) && Math.floor(pgeom.position.z.toFixed(2))==Math.floor(egeom.position.z.toFixed(2)) && win==false) {
				win = true;
				pgeom.material.opacity=1;
				skybox.visible = false;
			};
			if (scene.getObjectByName("key1") && Math.floor(pgeom.position.x.toFixed(2))==Math.floor(key.position.x.toFixed(2)) && Math.floor(pgeom.position.z.toFixed(2))==Math.floor(key.position.z.toFixed(2)) && scene.getObjectByName(doormesh.name)) {
				inventory.push(key.name);
				scene.remove(key);
				pgeom.add(key);
				key.rotation.set(0,0,Math.PI/2);
				key.position.set(1,-1,-2.5);
			};
			time = Date.now();
			if (startTime && win == false) {elapsed = (time - startTime); text2.innerHTML = elapsed.toString().toHHMMSS();};
			frames++;
			if (time>ptime+1000) {fps=Math.max(Math.round(frames*1000/(time-ptime)),6); ptime=Date.now(); frames=0}
			if (inventory.length < 1) {key.rotation.y += 0.01};
        };

		x = 8;
		y = 10;
		var a = 0
		if (x>y) {a=y; y=x; x=a;};
		init();
		mazegen(x,y);

		$("#WebGL-output").append(renderer.domElement);
        renderScene();
	  });
    </script>
  </body>
</html>